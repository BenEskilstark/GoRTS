
  - playtest:


  - bugs:


  - open issues:
    - dispatch action queue as a single action at the start of your turn
      - refactor reducers into separate ones
      - or actually just attach action queue to the END_TURN action

    - should be storing clientID on the pieces instead of bouncing off of color
      - clientID should be the thing and not color at all.

    - durations should be the turn that the event ends, not the duration
      because you can be off-by-one depending on when you receive that action
      - is there a way to encapsulate a duration into a class or something
        that takes care of itself?

    - tabbing away pauses the socket and messes with avg TR
      -  could have a timeout where the server ends your turn for you


  - alternate server models:
    - try running it on the server entirely (w/ roundtrip actions) just to
      see how it feels/profiles
    - have the server count the turns
      - have queues on the server for each client's actions and dispatch them
        on that client's turn.
      - but do you need a queue at all at that point? Couldn't there still be
        race conditions?
      - could use a CRDT-like that sends turn with all actions and first-write wins
        (but need to ensure all state is mergeable)
    - serialize state and send with END_TURN.
      - All other actions only happen on client
      - whenever you receive END_TURN, then deserialize the state that comes with it
        (ignore any state sent like this from a turn before your own(?))
      - if you took no actions on your turn, then could send empty state
      - this could allow switching to a server model by dispatching actions to
        server, END_TURN going empty, and then the server sending serialized
        state when it sends END_TURN
      - (de)serialization doesn't scale well...


  - more interesting game mechanics:


  - scoring:
    - just fill the entire board (except for eyes) and use sum of pieces
      when the game is obviously over?
      - could have a timeout where game is ended and scored if no one does
        anything for X turns
    - use floodfill algorithm on empty squares to count them up
      - how to handle ambiguous areas?
